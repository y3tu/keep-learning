### 1.`RegExp`对象

`javascript`中通过内置对象`RegExp`支持正则表达式，有两种方法实例化`RegExg`对象。

* 字面量
* 构造函数

#### 1.字面量

假设需要把一句英文里面的小写is匹配成大写的 IS，使用字面量：

```javascript
var reg = /\bis\b/;
var text = 'He is a boy, This is a dog. Where is she?';
var result = text.replace(reg,'IS');
console.log(result) //He IS a boy, This is a dog. Where is she?
```

这样就把第一个英文单词'is'替换成了'IS'，假如想把该句中所有的单词'is'都替换成'IS',应该这样写：

```javascript
var reg = /\bis\b/g;
var text = 'He is a boy, This is a dog. Where is she?';
var result = text.replace(reg,'IS');
console.log(result) //He IS a boy, This IS a dog. Where IS she?
```

在正则的末尾加上g就好，g表示global，是全局匹配的意思。'g'是正则表达式的一个修饰符。

- **g**: global 全文搜索。默认搜索到第一个就停止
- **i**: ignore case 忽略大小写。默认大小写敏感
- **m**: multiple 多行搜索 。检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用

为什么句子中的This中的is没有被匹配成功呢，因为`\b`

`\b`:匹配一个单词边界，也就是指单词和空格间的位置。例如，`er\b`可以匹配`never`中的`er`，但不能匹配`verb`中的`er`。

这里的正则在'is'的前后都有"\b"，这样就只能匹配单词is了。

#### 2.构造函数

使用构造函数的方式实例化正则：

```javascript
var reg = new RegExp('\\bis\\b','g');
var text = 'He is a boy, This is a dog. Where is she?';
var result = text.replace(reg,'IS');
console.log(result) //He IS a boy, This IS a dog. Where IS she?
```

用这种方式就不需要`/`符号开始和结尾以表示是正则了。但是里面的`\`等特殊字符需要用`\`转义。

`\`:将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，`n`匹配字符`n`。`\n`匹配一个换行符。串行`\\`匹配`\`而`\(`则匹配`(`。



### 2.元字符

正则表达式由两种基本字符类型组成：

* 原义文本字符，即代表它原本含义的字符
* 元字符，元字符是在正则表达式中有特殊含义的非字母字符，例如上文提到的`\b`，表示匹配单词边界，并不是匹配`\b`，在正则中主要存在这些特殊字符：`*,+,?,$,^,.,|,\,(,),{,},[,]`

#### 2.1 字符集合

使用元字符`[]`来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符。例如：表达式`[abc]`把字符a或b或c归为一类，表达式可以匹配这样的字符。

```javascript
var reg = /[abc]/g;
var text = 'a1b2c3d4';
var result = text.replace(reg,'X');
console.log(result); //X1X2X3d4
```

匹配的就是不是`abc`这样三个字符了，而是`abc`中任何一个字符，这就是元字符的一个应用。

#### 2.2 字符类取反

使用元字符`^`创建 **反向类/负向类**。

反向类的意思是**不属于类的内容**，表达式`[^abc]`表示**不是字符a或b或c**的内容

```javascript
var reg = /[^abc]/g;
var text = 'a1b2c3d4';
var result = text.replace(reg,'X');
console.log(result); //aXbXcXXX
```

#### 2.3 范围类

倘若需要用字符类匹配数字，按照前面的匹配方式，书写可能会很麻烦，需要这样：'[0123456789]'，对于 a 到 z 的字符更是如此。

为此，正则表达式给我们提供了**范围类**，我们可以使用`[a-z]`来连接两个字符，表示**从a到z的任意字符**，这是一个闭区间，包含 a 和 z 本身。

```javascript
var reg = /[a-z]/g;
var text = 'a1b2c3d4z9';
var result = text.replace(reg,'Q');
console.log(result); //Q1Q2Q3Q4Q9
```

此外，在`[]`组成的类的内部是可以连写的`[a-zA-Z]`，这样就形成了大写字母小写字母完全匹配

```javascript
var reg = /[a-zA-Z]/g;
var text = 'a1b2c3d4z9ASDFHDFH';
var result = text.replace(reg,'Q');
console.log(result); //Q1Q2Q3Q4Q9QQQQQQQQ
```

如果想连范围类里面的`-`字符也一起匹配，如下：

```javascript
var reg = /[0-9]/g; //这样是跟前面一样的结果，不行
var text = '2018-05-13';
var result = text.replace(reg,'Q');
console.log(result); //QQQQ-QQ-QQ

var reg = /[0-9-]/g; //只要在后面另外加一个‘-’符号就可以了
var text = '2018-05-13';
var result1 = text.replace(reg,'Q');
console.log(result1); //QQQQQQQQQQ
```

#### 2.4 预定义类及边界

* 预定义类

  



#### 前瞻，后顾，负前瞻，负后顾

``` 
// 前瞻：
exp1(?=exp2) 查找exp2前面的exp1
// 后顾：
(?<=exp2)exp1 查找exp2后面的exp1
// 负前瞻：
exp1(?!exp2) 查找后面不是exp2的exp1
// 负后顾：
(?<!exp2)exp1 查找前面不是exp2的exp1
```
举例
```
"中国人".replace(/(?<=中国)人/, "rr") // 匹配中国人中的人，将其替换为rr，结果为 中国rr
"法国人".replace(/(?<=中国)人/, "rr") // 结果为 法国人，因为人前面不是中国，所以无法匹配到
```
要理解?:则需要理解捕获分组和非捕获分组的概念
```
()表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n是一个数字，表示第n个捕获组的内容)
(?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来
```
举例
```
// 数字格式化 1,123,000
"1234567890".replace(/\B(?=(?:\d{3})+(?!\d))/g,",") // 结果：1,234,567,890，匹配的是后面是3*n个数字的非单词边界(\B)
```
