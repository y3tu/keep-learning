[TOC]

#### 面向对象的特征

* **封装**：封装是面向对象的特征之一，是对象和类概念的主要特性。把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的信息进行隐藏。

* **继承**：指使用现有类的所有功能，并在无需重新编写原来的类的情况下对功能进行扩展。

* **多态**：允许将子类类型的指针赋值给父类类型的指针。

  

#### Java语言的特点

* 简单易学（Java语言的语法与C语言和C++语言很接近）

* 面向对象（封装，继承，多态）

* 平台无关性（Java虚拟机实现平台无关性）

* 支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）

* 支持多线程（多线程机制使应用程序在同一时间并行执行多项任）

* 健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）

* 安全性



#### Java 中的数据类型

**基本数据类型**

* 整数型：byte、short、int、long

  byte 也就是字节，1 byte = 8 bits，byte 的默认值是 0 

  short 占用两个字节，也就是 16 位，1 short = 16 bits，它的默认值也是 0 

  int 占用四个字节，也就是 32 位，1 int = 32 bits，默认值是 0

  long 占用八个字节，也就是 64 位，1 long = 64 bits，默认值是 0L

  所以整数型的占用字节大小空间为 long > int > short > byte

* 浮点型：float 、double

  float 是单精度浮点型，占用 4 位，1 float = 32 bits，默认值是 0.0f

  double 是双精度浮点型，占用 8 位，1 double = 64 bits，默认值是 0.0d

  浮点型：float 、double

- 字符型

  字符型就是 char，char 类型是一个单一的 16 位 Unicode 字符，最小值是 `\u0000 (也就是 0 )`，最大值是 `\uffff (即为 65535)`，char 数据类型可以存储任何字符，例如 char a = 'A'。

* 布尔型

  布尔型指的就是 boolean，boolean 只有两种值，true 或者是 false，只表示 1 位，默认值是 false。


**引用数据类型**

* 类(class)
* 接口(interface)
* 数组([])



#### `JDK`、`JRE`、`JVM`

**JRE**：Java Runtime Environment, Java运行时环境。包含两部分内容：Jvm和标准实现和Java的一些基本类库。它相对于Jvm来说，多出来的是一部分Java类库。

**JDK**:  Java Development Kit, Java开发工具包。Jdk是整个Java开发的核心，它集成了Jre和一些其他工具，比如：`javac.exe`,`java.exe`,`jar.exe`等

**JVM**: Java Virtual Machine,Java虚拟机。虚拟机是Java实现跨平台的核心。



#### 值传递和引用传递

**值传递**：是指在调用函数时将实际参数复制一份到函数中，这样的话如果函数对其传递过来的形式参数进行修改，将不会影响到实际参数。

**引用传递**： 是指在调用函数时将对象的地址直接传递到函数中，如果在对形式参数进行修改，将影响到实际参数的值

#### Java中的克隆

1.**为什么使用clone？**

在实际编程过程中，我们常常要遇到这种情况：有一个对象 A，在某一时刻 A 中已经包含了一些有效值，此时可能会需要一个和 A 完全相同新对象B，并且此后对 B 任何改动都不会影响到 A 中的值，也就 是说，A 与 B 是两个独立的对象，但 B 的初始值是由 A 对象确定的。在 Java 语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但clone()方法是其中最简单，也是最高效的手段。

2.**深克隆和浅克隆？**

**浅克隆**：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性 所指向的对象的内存地址。 

**深克隆**：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

3.**new一个对象的过程和clone一个对象的区别**

new 操作符的本意是分配内存。程序执行到 new 操作符时，首先去看 new 操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域， 这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。 clone 在第一步是和 new 相似的，都是分配内存，调用 clone 方法时，分配的内存和原对象（即调用 clone 方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone 方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。

#### Java中异常分类

按照异常需要处理的时机分为编译时异常(也叫受控异常)也叫 `CheckedException` 和运行时异常(也叫非受控异常)也叫` UnCheckedException`。Java认为Checked异常都是可以被处理的异常，所以Java程序必须显式处理Checked异常。如果程序没有处理Checked 异常，该程序在编译时就会发生错误无法编译。这体现了Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行。对Checked异常处理方法有 两种：

- 当前方法知道如何处理该异常，则用try...catch块来处理该异常。
- 当前方法不知道如何处理，则在定义该方法时声明抛出该异常。

运行时异常只有当代码在运行时才发行的异常，编译的时候不需要try…catch。

**常见异常:**

* `NullPointerException`: 空指针异常

* `NoSuchMethodException`：找不到方法

* `IllegalArgumentException`：不合法的参数异常

* `IndexOutOfBoundException`: 数组下标越界异常

* `IOException`：由于文件未找到、未打开或者I/O操作不能进行而引起异常

* `ClassNotFoundException` ：找不到文件所抛出的异常

* `NumberFormatException`： 字符的UTF代码数据格式有错引起异常；

* `InterruptedException`： 线程中断抛出的异常
