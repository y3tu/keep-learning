### 概述

#### 什么是设计模式

设计模式是代码开发经验的总结，用于提高代码的可复用性、可维护性、可读性、稳健性和安全性。

设计模式的本质是面向对象设计原则的实际运用，是对类的封装、继承、多态以及类的关联关系和组合关系的充分理解。

#### 设计模式七大原则

* **开闭原则**：对扩展开放，对修改关闭。也就是说扩展的代码尽量不影响原有代码，尽量做到独立。
* **里氏替换原则**：继承必须确保超类所拥有的属性在子类中仍然成立，也就是说子类要在父类的基础上扩展添加新的东西，而不是修改父类原有的方法。
* **依赖倒置原则**：面向接口编程，不要面向实现。
* **单一职责原则**：控制类的粒度，将对象解耦，提高内聚。就是说一个对象或一个方法不应该承担太多的职责，否则会有很多冗余，粒度太粗。
* **接口隔离原则**：要为每个类建立他们需要的专用接口。
* **迪米特原则**：只和直接相关联的对象通信，不和其他对象通信。
* **合成复用原则**：尽量先使用组合、聚合这种关联关系来实现，其次才考虑继承关系实现。

#### 分类

设计模式可以分为三类：

* **创建型**（主要用于创建对象）
  * 单例模式
  * 简单工厂模式
  * 抽象工厂模式
  * 工厂模式
  * 建造者模式
  * 原型模式
* **行为型**（用于描述类或对象怎么交互和分配职责）
  * 责任链模式
  * 命令模式
  * 解释器模式
  * 迭代器模式
  * 中介者模式
  * 备忘录模式
  * 观察者模式
  * 状态模式
  * 策略模式
  * 模板方法模式
  * 访问模式
* **结构型**（用于处理类和对象的组合）
  * 适配器模式
  * 桥接模式
  * 组合模式
  * 装饰模式
  * 外观模式
  * 享元模式
  * 代理模式



### 创建型模式

#### 单例模式

确保一个类只有一个实例，并且提供一个全局访问点。

* 饿汉式

类加载时就实例化

```java
public class HungryDemo{
  	//私有的构造函数，不能通过构造函数实例化
    private HungryDemo() {      
    }
    private final static HungryDemo hungryDemo = new HungryDemo();
    public static HungryDemo getInstance() {
        return hungryDemo;
    }
}
```

* 懒汉式

调用的时候才初始化

```java
public class LazyDemo{
    //构造函数私有，不能通过构造函数实例化
    private LazyDemo() {        
    }
    private static LazyDemo lazyDemo = null;
  	//非线程安全
    public static LazyDemo getInstance() {
      if (lazyDemo==null) {
        lazyDemo = new LazyDemo();
      }
      return lazyDemo;
    }
}
```

* 双重检验锁（DCL double-checked locking）

```java
public class DoubleCheckDemo{
    private DoubleCheckDemo() {
    }
    //voliatile此处是禁止指令重排序的作用
    private volatile static DoubleCheckDemo doubleCheckDemo = null;
    public static DoubleCheckDemo getInstance() {
        if (doubleCheckDemo==null) {
          synchronized(DoubleCheckDemo.class) {
            if (doubleCheckDemo==null) {
              doubleCheckDemo = new DoubleCheckDemo();
            }
          } 
        }
      return doubleCheckDemo;
    }
}
```

这是线程安全的单例。

除了使用synchronized之外，还加上了volatile修饰符。因为DCL本身存在一个缺陷就是重排序可能导致多线程获取到一个未初始化的对象。

doubleCheckDemo = new DoubleCheckDemo()在JVM中分为三步：

1. 为对象分配空间
2. 初始化对象
3. 将doubleCheckDemo的引用指向第一步中分配的内存地址。

如果线程A执行第2步和第3步时发生重排序，此时线程B进来后发现`doubleCheckDemo!=null`成立就直接返回了一个未初始化的对象，volatile可以保证多线程环境下变量的可见性和禁止指令重排序。

* 静态内部类

```java
public class StaticInnerClassDemo{
  private StaticInnerClassDemo() {
  }
  public static StaticInnerClassDemo getInstance() {
    return InnerClass.staticInnerClassDemo;
  }
  public static class InnerClass{
      private static final StaticInnerClassDemo staticInnerClassDemo = new StaticInnerClassDemo();
  }
}
```

* 枚举类

```java
public enum EnumDemo {
  INSTANCE;
  public EnumDemo getInstance() {
    return INSTANCE;
  }
}
```



#### 简单工厂模式

```java
public class SimpleFactory {
    public static Food makeFood(String name) {
        if (name.equals("noodle")) {
            return new HeNanNoodle();
        } else if (name.equals("chicken")) {
            return new HuangMenChicken();
        } else {
            return null;
        }
    }
    public static abstract class Food {
    }
    public static class HeNanNoodle extends Food{
    }
    public static class HuangMenChicken extends Food{
    }
}
```

简单工厂模式只有一个工厂类，里面有一个静态方法，根据传入不同的参数，返回不同的派生自同一个父类的实例对象。



#### 工厂模式

------

如果简单工厂模式能够满足需求就不需要工厂模式，之所以有工厂模式，是因为需要使用两个或两个以上的工厂。

