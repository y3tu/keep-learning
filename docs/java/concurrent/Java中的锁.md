|   锁名称 | 应用                                                         |
| -------: | ------------------------------------------------------------ |
|   乐观锁 | CAS                                                          |
|   悲观锁 | synchronized、Reentrantlock、vector、hashtable               |
|   自旋锁 | CAS                                                          |
| 可重入锁 | synchronized、Reentrantlock、Lock                            |
|   读写锁 | ReentrantReadWriteLock，CopyOnWriteArrayList、CopyOnWriteArraySet |
|   公平锁 | Reentrantlock(true)                                          |
| 非公平锁 | synchronized、reentrantlock(false)                           |
|   共享锁 | ReentrantReadWriteLock中读锁                                 |
|   独占锁 | synchronized、vector、hashtable、ReentrantReadWriteLock中写锁 |
| 重量级锁 | synchronized                                                 |
| 轻量级锁 | 锁优化技术                                                   |
|   偏向锁 | 锁优化技术                                                   |
|   分段锁 | concurrentHashMap                                            |
|   互斥锁 | synchronized                                                 |
|     死锁 | 相互请求对方的资源                                           |
|   锁粗化 | 锁优化技术                                                   |
|   锁消除 | 锁优化技术                                                   |



### 1.乐观锁

>读不加锁，更新数据期间会加锁(保证原子性)

**读数据时:** 会很乐观的认为别的线程没有在修改数据，所以不会上锁。

**写数据时:** 会判断当前值和期望值一不一样，一样的话会进行修改，此时修改会加锁

**实现方式:** CAS 机制(Compare And Swap / Set)、版本号机制，时间戳机制

为什么会多后面两种机制呢，其实这里是为了解决这个 **ABA 问题**

场景模拟，现在有三条线程,

线程1 读取变量a，此时a=1

线程2 读取变量a，此时a=1, 比较后将它改为 a=2

线程3 读取变量a，此时a=2, 比较后将它改为 a=1

这时线程1 发现变量a 还是1 ，和原来一样，就将它改成其他值了

可以发现这个过程中 线程1 在修改值的时候，线程2,3已经修改过变量a的值了，但是它毫不知情

所以呢，为了解决这个问题，就引入了这个**版本号机制 或者 时间戳机制**

其实就是多比较一个值，比如 **每次更改时再比较下这个版本号或者时间戳对不对得上**

**原子类中的** `AtomicStampedReference` ，它就解决了这个 **ABA 问题**



### 2.悲观锁

> 悲观的认为，读写都要加锁，不然值会被其他线程改变

**实现方式:** `synchronized`，`Reentrantlock`



### 3.自旋锁

> 让线程不断地循环，去尝试获取锁

**实现方式:** CAS操作中的比较操作失败后的自旋等待。

**优点：**避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。

**缺点：** 占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源，而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。

**自适应自旋：** 自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越精准。



### 4.可重入锁(递归锁)

> 当一个线程持有某个锁时,**可以再次获取该锁而不会导致死锁或者阻塞**
>
> 获取 n 次 锁 ，也要释放 n 次锁
>
> 避免死锁

**实现方式：**`synchronized`，`ReentrantLock`

**可重入锁的原理：** 通过组合自定义同步器来实现锁的获取与释放。

- 再次获取锁：识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。获取锁后，进行计数自增

- 释放锁：释放锁时，进行计数自减

  

### 5.读写锁

> 表示该资源允许 **多条持有读锁的线程共同访问，但是只允许一条持有写锁的线程独占**
>
> **读读不互斥**
>
> **读写互斥**
>
> **写写互斥**

**实现方式：**`ReentrantReadWriteLock`，`ReadWriteLock`

为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。 读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的。

**使用：**

```java
/**
* 创建一个读写锁
* 它是一个读写融为一体的锁，在使用的时候，需要转换
*/
private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

// 获取读锁
rwLock.readLock().lock();

// 释放读锁
rwLock.readLock().unlock();

// 创建一个写锁
rwLock.writeLock().lock();

// 写锁 释放
rwLock.writeLock().unlock();
```



### 6.公平锁

> 多个线程按照申请锁的顺序来获取锁

**公平锁原理：** 主要依赖于维护这个锁的 **等待队列**，当队列为空时就直接占有锁, 不为空就加入到 **等待队列** 的末尾，然后按照 **FIFO** 的原则去获取锁

**实现方式：**创建 **`ReentrantLock`** 时，显示指定 `new ReentrantLock(true)`



### 7.非公平锁

> 多个线程 不按照先到先得的方式去获取锁， 有可能后申请的线程会先得到锁

**非公平锁原理：**非公平锁会尝试获取锁，失败的话会加入到 **等待队列** 的末尾，然后按照 **FIFO** 的原则去获取锁 ，变成公平锁的方式

**优点：** 非公平锁的性能高于公平锁。

**缺点：** 有可能造成线程饥饿（某个线程很长一段时间获取不到锁）

**实现方式：**创建 `ReentrantLock` 时，显示指定 `new ReentrantLock(false)` 或者使用默认的方式 `new ReentrantLock();`

还有 `synchronized` 这个关键字也是非公平的



### 8.共享锁

> 锁可被多个线程所持有。和乐观锁，读写锁同义

**实现方式：**`ReentrantReadWriteLock` ，`ReadWriteLock` 这两个中的 **读锁**



### 9.独享锁(独占锁)

> 只允许一条线程占有该锁。和互斥锁，排他锁，悲观锁同义

**实现方式：**`synchronized` ，`ReentrantLock` 还有 `ReentrantReadWriteLock` 中 的 **写锁**



### 10.重量级锁

**重量级锁是一种称谓：** `synchronized`是通过对象内部的一个叫做监视器锁（`monitor`）来实现的，监视器锁本身依赖底层的操作系统的 `Mutex Lock`来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统 `Mutex Lock`来实现的锁称为重量级锁。为了优化`synchonized`，引入了轻量级锁，偏向锁。

**实现方式：**`synchronized` 



### 11.轻量级锁

**轻量级锁是JDK6时加入的一种锁优化机制：** 轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。轻量级是相对于使用操作系统互斥量来实现的重量级锁而言的。轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁将不会有效，必须膨胀为重量级锁。

**优点：** 如果没有竞争，通过CAS操作成功避免了使用互斥量的开销。

**缺点：** 如果存在竞争，除了互斥量本身的开销外，还额外产生了CAS操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。



### 12.偏向锁

**偏向锁是JDK6时加入的一种锁优化机制：** 在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。

**优点：** 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁。

**缺点：** 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。



### 13.分段锁

**分段锁是一种机制：** 最好的例子来说明分段锁是`ConcurrentHashMap`。

**`ConcurrentHashMap`原理：**它内部细分了若干个小的` HashMap`，称之为段(Segment)。 默认情况下一个 `ConcurrentHashMap` 被进一步细分为 16 个段，既就是锁的并发度。如果需要在 `ConcurrentHashMap` 添加一项key-value，并不是将整个 `HashMap` 加锁，而是首先根据 `hashcode `得到该key-value应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并行。

**线程安全：**`ConcurrentHashMap `是一个 Segment 数组， Segment 通过继承`ReentrantLock` 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全



### 14.互斥锁(同步锁)

>互斥锁与悲观锁、独占锁同义，表示某个资源只能被一个线程访问，其他线程不能访问
>
>- 读-读互斥
>- 读-写互斥
>- 写-读互斥
>- 写-写互斥

 **实现方式：**`synchronized` 



### 15.死锁

> 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获取不到对方的资源，就会造成死锁。

Java中的死锁不能自行打破，所以线程死锁后，线程不能进行响应。所以一定要注意程序的并发场景，避免造成死锁



### 16.锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。



### 17.锁消除

就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。

那如何判断共享数据不会被线程竞争？

利用逃逸分析技术：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。

在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，认为它是线程私有的，同步加锁就不需要了。





