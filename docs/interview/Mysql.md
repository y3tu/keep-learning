### 1. 数据库事务有哪些特性？

- **原子性**：组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功，整个事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始状态。
- **一致性**：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。 如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的。
- **隔离性**：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰。
- **持久性**：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。



### 2. 有哪些常用的`sql`优化手段？

- 查询语句中不要使用`select * `
- 尽量减少子查询，使用关联查询替代
- 尽量使用`exists,not exists`或者关联查询语句代替`in,not in`
- `or `的查询尽量用 `union`或者`union all` 代替(在确认没有重复数据或者不用剔除重复数据时， `union all`会更好)
- 应尽量避免在 `where`子句中使用`!=或<>`操作符，否则将引擎放弃使用索引而进行全表扫描。
- 应尽量避免在`where`子句中对字段进行 `null `值判断，否则将导致引擎放弃使用索引而进行全表 扫描，如：` select id from t where num is null `可以在`num`上设置默认值0，确保表中`num`列没有 null值，然后这样查询：` select id from t where num=0`

### 3. drop、delete与truncate有什么区别？

`SQL`中的`drop、delete、truncate`都表示删除。

`delete`和`truncate`**只删除表的数据不删除表的结构** 

运行速度,一般来说: `drop> truncate >delete `

`delete `语句是`dml`,这个操作会放到`rollback segement`中,事务提交之后才生效; 如果有相应的trigger,执行的时候将被触发。`truncate,drop`是`ddl`, 操作立即生效,原数据不放到`rollback segment`中，不能回滚，操作不触发trigger。



### 4. 并发事务有哪些问题？

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

* **脏读**：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是**脏数据**，对脏数据进行的操作可能是不正确的。

* **丢失修改**：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 

  例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

* **不可重复读**：: 指在一个事务内多次读同一数据。在这个事务还没有结 束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

* **幻读**：幻读与不可重复读类似。它发生在一个事务`T1`读取了几行数据，接着另一个并发事务`T2`插入了一些数据时。在随后的查询中，第一个事务`T1`就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。



**不可重复读和幻读的区别**：

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。



### 5. 事务隔离级别有哪些？`Mysql`的默认隔离级别是什么？

`SQL`标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读未提交)** : 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- **READ-COMMITTED(读已提交)** ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- **REPEATABLE-READ(可重复读)** ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- **SERIALIZABLE(可串行化)** ： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读 以及幻读。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | √    | √          | √    |
| 读已提交 | ×    | √          | √    |
| 可重复读 | ×    | ×          | √    |
| 可串行化 | ×    | ×          | ×    |

`MySQL InnoDB `存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重复读）**。

这里需要注意的是：与 `SQL` 标准不同的地方在于 `InnoDB` 存储引擎在 `REPEATABLE-READ（可重复读）`事务隔离级别下使用的是`Next-Key Lock` 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 `SQL Server`) 是不同的。所以说`InnoDB `存储引擎的默认支持的隔离级别是`REPEATABLE-READ（可重读）` 已经可以完全保证事务的隔离性要求，即达到了 `SQL`标准的 `SERIALIZABLE(可串行化)` 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是`READ-COMMITTED(读取提交内容)` ，但是你要知道的是`InnoDB` 存储引擎默认使用 `REPEATABLE-READ（可重读)` 并不会有任何性能损失。

` InnoDB` 存储引擎在分布式事务 的情况下一般会用到 `SERIALIZABLE(可串行化) `隔离级别。



### 6. 大表如果优化？

当`MySQL`单表记录数过大时，数据库的`CRUD`性能会明显下降，一些常见的优化措施如下：

- 限定数据的范围

务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。

* 读/写分离

经典的数据库拆分方案，主库负责写，从库负责读。

- 垂直拆分

**根据数据库里面数据表的相关性进行拆分**。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。 简单来说**垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表**。

**优点**：可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外， 垂直拆分可以简化表的结构，易于维护。

**缺点**：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直拆分会让事务变得更加复杂。

* 水平拆分

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的**。 水平拆分可以支撑非常大的数据量。

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据 拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问 题，但由于表的数据还是在同一台机器上，其实对于提升`MySQL`并发能力没有什么意义，所以**水平拆分最好分库** 。

数据库分片的两种常见方案： 

- **客户端代理**： 分片逻辑在应用端，封装在jar包中，通过修改或者封装`JDBC`层来实现。 当当网的 `Sharding-JDBC` 、阿里的`TDDL`是两种比较常用的实现。 
- **中间件代理**： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 `Mycat` 、360的`Atlas`、网易的`DDB`等等都是这种架构的实现。



### 7. 索引有哪些优缺点？

* **优点**：
  - **提高数据的检索速度，降低数据库IO成本**：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。
  - **降低数据排序成本，降低CPU消耗**：索引之所以快，是因为先将数据排好序，若该字段正好需要排序，则正好降低排序的成本。
* **缺点**：
  - **占用存储空间**：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。
  - **降低更新表的速度**：表的数据发生变化，对应的索引也需要一起变更，从而降低更新速度。如果不更新索引，索引指向的物理数据可能是错误的，这也是索引失效的原因之一。



### 8. 哪些场景下索引会失效？

-  使用select *

- 不满足最左匹配原则

- 索引列有运算符

- 索引列使用函数

- 字段类型不同，列类型是字符串类型的，查询时一定要给值加上引号，否则索引会失效

- 模糊查询like左边包含%，如果需要模糊匹配，可以使用全文索引

- 使用or关键字

- not in和not exists

  

### 9. 对`SQL`慢查询会考虑哪些优化？

- 分析语句，是否加载了不必要的字段/数据。
- 分析 `SQL` 执行计划（`explain extended`），思考可能的优化点，是否命中索引等
- 查看 `SQL` 涉及的表结构和索引信息。
- 如果 `SQL `很复杂，优化 `SQL `结构。
- 按照可能的优化点执行表结构变更、增加索引、`SQL` 改写等操作
- 查看优化后的执行时间和执行计划。
- 如果表数据量太大，考虑分表。
- 利用缓存，减少查询次数。



### 10. `MySQL` 中有哪几种锁？

- **表级锁**：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- **行级锁**：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- **页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之 间，并发度一般。
